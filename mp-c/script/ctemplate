#!/bin/bash
#---------------------------------------------------------------------
#
# A simple template for bash shellscripts with help information, 
# color coding etc.
#
# Author: Peter Malmberg <peter.malmberg@gmail.com>
#
#---------------------------------------------------------------------
#

# Directory where script is located
BASEDIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )

#--------------------------------------------------------------------- 
# System functions and settings
#---------------------------------------------------------------------

# ANSI foreground colors codes
#
E_BLACK='\e[0;30m'        # Black
E_RED='\e[0;31m'          # Red
E_GREEN='\e[0;32m'        # Green
E_YELLOW='\e[0;33m'       # Yellow
E_BLUE='\e[0;34m'         # Blue
E_MAGENTA='\e[0;35m'      # Magenta
E_CYAN='\e[0;36m'         # Cyan
E_GRAY='\e[0;37m'         # Gray
E_DARKGRAY='\e[1;30m'     # Dark Gray
E_BR_RED='\e[1;31m'       # Bright Red
E_BR_GREEN='\e[1;32m'     # Bright Green
E_BR_YELLOW='\e[1;33m'    # Bright Yellow
E_BR_BLUE='\e[1;34m'      # Bright Blue
E_BR_MAGENTA='\e[1;35m'   # Bright Magenta
E_BR_CYAN='\e[1;36m'      # Bright Cyan
E_WHITE='\e[1;37m'        # White

# ANSI background color codes
#
E_ON_BLACK='\e[40m'         # Black
E_ON_RED='\e[41m'           # Red
E_ON_GREEN='\e[42m'         # Green
E_ON_YELLOW='\e[43m'        # Yellow
E_ON_BLUE='\e[44m'          # Blue
E_ON_MAGENTA='\e[45m'       # Magenta
E_ON_CYAN='\e[46m'          # Cyan
E_ON_WHITE='\e[47m'         # White

# ANSI cursor operations
#
E_RETURN="\e[F"           # Move cursor to begining of line
E_UP="\e[A"               # Move cursor one line up
E_DOWN="\e[B"             # Move cursor one line down
E_FORWARD="\e[C"          # Move cursor forward
E_BACK="\e[D"             # Move cursor backward
E_HIDE="\e[?25l"          # Hide cursor 
E_SHOW="\e[?25h"          # Show cursor 

E_END="\e[m"              # Clear Attributes

E_INFO=$E_BR_CYAN
E_WARNING=$E_BR_YELLOW
E_ERROR=$E_BR_RED
E_CRITICAL=$E_ON_RED$E_WHITE

printLine() {
  echo -e "${E_BOLD_WHITE}------------------------------------------------------------------------------${E_END}"
}

#--------------------------------------------------------------------- 
# Add your code after here 
#---------------------------------------------------------------------

#
# Replace tag ing file
#
# $1  tag to be replaced
# $2  replacement string
# $3  file to replace in
#
setTag() {
#  echo $1 $2 $3
  sed  -i.bak "s/$1/$2/" $3 
	rm $3.bak
}


newhfile() {
  sleep 1
}


addSection() {
  echo -e "/**\n"   \
	        "* $1\n"  \
	        "*------------------------------------------------------------------\n" \
					"*/\n" >> $2
}

addSections() {
  addSection "Defines"   $1
	addSection "Variables" $1
	addSection "Body"      $1
}

addHeader() {
	# creating files
	echo "Creating $1"
	cat ${BASEDIR}/header.txt > $1
}

addSentinel() {
	# adding sentintels to h file
  sentinel=${filename^^}_H
  echo "#ifndef $sentinel" >> $1
	echo -e "#define $sentinel\n\n\n" >> $1
	echo "#endif" >> $1

}

test() { ## Test command
  read -e -i "Y" -p "Test [YN] >" aa 
	echo "Test " $aa
}

cfile() { ## Create a new C file

  # get the filenames
  read -p "Name of new C file: >" filename
	sourcefile=$2/${filename}.c
	headerfile=$2/${filename}.h
	hfile=${filename}.h
	
	# timestamp
	ts=`date +"%Y-%m-%d %H:%M:%S"`
	
	# creating files
	echo "Creating $sourcefile"
	cat ${BASEDIR}/header.txt > $sourcefile
	echo "Creating $headerfile"
	cat ${BASEDIR}/header.txt > $headerfile
	
  # adding include to c file
	echo -e "\n#include \"$hfile\"\n" >> $sourcefile
	
	# add sentintels to header file
	addSentinel $headerfile
	
	# add section to c file
	addSections $sourcefile

	# setting tags
	setTag __FILE__ $(basename $sourcefile) $sourcefile
	setTag __FILE__ $(basename $headerfile) $headerfile
	setTag __DATE__ "${ts}" $sourcefile
	setTag __DATE__ "${ts}" $headerfile

	
#	printLine
#	cat $headerfile
#	cat $sourcefile
#	printLine
}

cppfile() { ## Create a new C++ file
  sleep 1
}


#--------------------------------------------------------------------- 
# 
#---------------------------------------------------------------------

#
# Function logging to file
#
# Arg1 String to log to file
# 
bpLog() {
  # check for LOGFILE variable
	if [ -n "$LOGFILE" ]; then
	  ts=$(date +"%Y-%m-%d %H:%M:%S")
 	  echo $ts $1 >> ${LOGFILE}
	fi
}

log() { ## View logfile
  D=$(sed -r -e "s|\[Info\]|\[\\${E_INFO}Info\\${E_END}\]|"  \
	        -e "s|\[Warn\]|\[\\${E_WARNING}Warn\\${E_END}\]|"  \
	        -e "s|\[Erro\]|\[\\${E_ERROR}Erro\\${E_END}\]|"    \
					-e "s/[-0-9]+/\\${E_GREEN}&\\${E_END}/1"            \
					-e "s/[:0-9]+/\\${E_BR_GREEN}&\\${E_END}/6"            \
	        -e "s|\[Crit\]|\[\\${E_ON_RED}\\${E_WHITE}Crit\\${E_END}\]|" < ${LOGFILE} ) 

	echo -e "$D"
}


bpInfo() {
  bpLog "[Info] $1"
	echo -e "[${E_INFO}Info${E_END}] $1"
}

bpWarning() {
  bpLog "[Warn] $1"
  echo -e "[${E_WARNING}Warn${E_END}] $1"
}

bpError() {
  bpLog "[Erro] $1"
  echo -e "[${E_ERROR}Erro${E_END}] $1"
}

bpCritical() {
  bpLog "[Crit] $1"
  echo -e "[${E_CRITICAL}Crit${E_END}] $1"
	exit
}


# Change setting in config file (key value pair)
#
# arg1 config file
# arg2 setting to change
# arg3 new value for setting
#
chSetting() { 
  SETTING=$2
	VAL=$3
	sed -i "s/^\(${SETTING}\s*=\s*\).*\$/\1$VAL/" $1
}

help() { ## Print this help information
	echo $USAGE
	echo -e $DESC
	echo 
	printf "%-20s  %s\n" "Command" "Help"
	printLine
	IFS=$'\n'
  help_lines=`grep -h "##" $0 | grep -v grep | grep -v help_line`
	for help_line in ${help_lines[@]}; do                                     
    help_command=`echo $help_line | sed -s 's/(.*//'`
		help_info=`echo $help_line | sed -s 's/^.*##//'`
	  printf "${E_BR_CYAN}%-20s %s${E_END}" $help_command                  
	  printf "${E_BR_GREEN}%s${E_END}\n" $help_info
	done 
	printLine
	echo
}

version() { ## Print version information
  echo $VERSION
}

# Runs a function in this file as a command
runCommand() {
	if [ $# == "1" ]; then
	 
	  # check for a default command
	  if [ -n "$DEFAULT" ]; then
		  $DEFAULT
		  exit
		fi
		
	  echo -e ${E_BOLD_RED}"No command given"${E_END}
		help
		exit
	fi
  funks=`grep "##" $0 | grep -v grep | grep -v help_line`
	for line in ${funks[@]}; do
	  command=`echo $line | sed -s 's/(.*//'`
		if [ "$command" == "$1" ]; then
		  $command $1 $2 $3 $4 $5 $6 $7 $8 $9 $10
			exit
		fi
	done
	echo -e ${E_BOLD_RED}"Command not found"${E_END}
	help
	exit 
}

runCommand $1 $2 $3 $4 $5 $6 $7 $8 $9 $10
